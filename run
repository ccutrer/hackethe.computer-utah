#!/usr/bin/env ruby

#require 'byebug'
require 'set'

class Cube
  attr_reader :canonicals, :faces

  def initialize(net)
    @width, @height, @multiplier = self.class.infer_multiplier(net)

    x = (@width - 1) / 2
    y = (@height  - 1) / 2

   # debugger
    @faces = {}
    @faces[:top] = extract_face(net, x, y)
    # given top as center (B = Back, b = Bottom, X = bottom OR another, depending on how you got there):
    # rotate faces so that top's top is towards back, sides' top towards top, bottom's top towards front
    #
    #  XbX
    # FLBRF
    #   T
    # BLFRB
    #  XbX
    #
    #  OR
    #
    #  b b
    # XB BX
    # bLTRb
    # XF FX
    #  b b
    @faces[:back] = back1 = rotate_face(extract_face(net, x, y - 1), :half) # checked
    @faces[:front] = front1 = extract_face(net, x, y + 1) # checked
    @faces[:left] = left1 = rotate_face(extract_face(net, x - 1, y), :counterclockwise) # checked
    @faces[:right] = right1 = rotate_face(extract_face(net, x + 1, y), :clockwise) # checked
    if back1
      @faces[:bottom] ||= bottom2 = extract_face(net, x, y - 2) # checked
      @faces[:left] ||= left2 = rotate_face(extract_face(net, x - 1, y - 1), :half) # checked
      @faces[:right] ||= right2 = rotate_face(extract_face(net, x + 1, y - 1), :half) # checked
      if bottom2
        @faces[:left] ||= rotate_face(extract_face(net, x - 1, y - 2), :clockwise) # checked
        @faces[:right] ||= rotate_face(extract_face(net, x + 1, y - 2), :counterclockwise) # checked
      end
      if left2
        @faces[:bottom] ||= rotate_face(extract_face(net, x - 1, y - 2), :clockwise) # checked
        @faces[:front] ||= rotate_face(extract_face(net, x - 2, y - 1), :half) # checked
      end
      if right2
        @faces[:bottom] ||= rotate_face(extract_face(net, x + 1, y - 2), :counterclockwise) # checked
        @faces[:front] ||= rotate_face(extract_face(net, x + 2, y - 1), :half) # checked
      end
    end
    if front1
      @faces[:bottom] ||= bottom3 = extract_face(net, x, y + 2) # checked
      @faces[:left] ||= left3 = extract_face(net, x - 1, y + 1) # checked
      @faces[:right] ||= right3 = extract_face(net, x + 1, y + 1) # checked
      if bottom3
        @faces[:left] ||= rotate_face(extract_face(net, x - 1, y + 2), :clockwise) # checked
        @faces[:right] ||= rotate_face(extract_face(net, x + 1, y + 2), :counterclockwise) # checked
      end
      if left3
        @faces[:back] ||= extract_face(net, x - 2, y + 1) # checked
        @faces[:bottom] ||= rotate_face(extract_face(net, x - 1, y + 2), :counterclockwise) # checked
      end
      if right3
        @faces[:back] ||= rotate_face(extract_face(net, x + 2, y + 1), :confused)
        @faces[:bottom] ||= rotate_face(extract_face(net, x + 1, y + 2), :confused)
      end
    end
    #  R L
    # XB BX
    # bLTRbL
    # XF FX
    #  R L
    if left1
      @faces[:bottom] ||= bottom4 = rotate_face(extract_face(net, x - 2, y), :half) # checked
      @faces[:back] ||= back4 = rotate_face(extract_face(net, x - 1, y - 1), :counterclockwise) # checked
      @faces[:front] ||= front4 = rotate_face(extract_face(net, x - 1, y + 1), :counterclockwise) # checked
      if bottom4
        @faces[:back] ||= rotate_face(extract_face(net, x - 2, y - 1), :confused)
        @faces[:front] ||= rotate_face(extract_face(net, x - 2, y + 1), :confused)
      end
      if back4
        @faces[:right] ||= rotate_face(extract_face(net, x - 1, y - 2), :confused)
        @faces[:bottom] ||= rotate_face(extract_face(net, x - 2, y - 1), :confused)
      end
      if front4
        @faces[:right] ||= rotate_face(extract_face(net, x - 2, y + 2), :confused)
        @faces[:bottom] ||= rotate_face(extract_face(net, x - 2, y + 1), :confused)
      end
    end
    if right1
      @faces[:bottom] ||= bottom5 = rotate_face(extract_face(net, x + 2, y), :half) # checked
      @faces[:back] ||= back5 = rotate_face(extract_face(net, x + 1, y - 1), :clockwise) # checked
      @faces[:front] ||= front5 = rotate_face(extract_face(net, x + 1, y + 1), :clockwise) # checked
      if bottom5
        @faces[:back] ||= rotate_face(extract_face(net, x + 2, y - 1), :confused)
        @faces[:front] ||= rotate_face(extract_face(net, x + 2, y + 1), :confused)
      end
      if back5
        @faces[:left] ||= rotate_face(extract_face(net, x + 2, y - 2), :confused)
        @faces[:bottom] ||= rotate_face(extract_face(net, x + 2, y - 1), :counterclockwise) # checked
      end
      if front5
        @faces[:left] ||= rotate_face(extract_face(net, x + 1, y + 2), :confused)
        @faces[:bottom] ||= rotate_face(extract_face(net, x + 2, y + 1), :confused)
      end
    end

    scores = @faces.map { |name, face| [name, self.class.score_face(face)] }.sort_by(&:last)

    target_tops = scores.select { |(_name, score)| score == scores.first.last}.map(&:first)

    canonicals = target_tops.map do |target|
      cube = dup
      case target
        when :front
          cube.flip_up
        when :right
          cube.rotate
          cube.flip_up
        when :back
          cube.rotate
          cube.rotate
          cube.flip_up
        when :left
          cube.rotate
          cube.rotate
          cube.rotate
          cube.flip_up
        when :bottom
          cube.flip_up
          cube.flip_up
        when :top
      end

      # the top has no orientation; try the sides?
      #if @multiplier == 1 || (rotation1 = self.class.rotate_face(cube.faces[:top])) == cube.faces[:top]
      cube
    end.flatten
    @canonicals = canonicals.map(&:canonical)
  end

  def extract_face(lines, x, y)
    return nil if x < 0 || y < 0 || x >= @width || y >= @height
    return nil if lines[y * @multiplier][x * @multiplier] == ' ' ||
        lines[y * @multiplier][x * @multiplier].nil?
    lines.slice(y * @multiplier, @multiplier).map do |row|
      row.slice(x * @multiplier, @multiplier)
    end
  end

  def self.infer_multiplier(net)
    width = net.map(&:length).max
    height = net.length
    if height > width * 2
      # the 2x5 net
      multiplier = height / 5
    elsif width > height * 2
      # the 2x5, rotated
      multiplier = width / 5
    else
      # one of the 3x4 nets
      multiplier = [width, height].max / 4
    end
    width /= multiplier
    height /= multiplier
    [width, height, multiplier]
  end

  def rotate_face(face, direction)
    return nil unless face
    if direction == :confused
      sleep 5
      exit 1
    end
    self.class.send("rotate_face_#{direction}", face)
  end

  def self.rotate_face_clockwise(face)
    width = face.map(&:length).max
    height = face.length
    new_face = Array.new(width)
    new_face.map! { String.new.ljust(height) }
    (0...width).each do |i|
      (0...height).each do |j|
        new_face[i][j] = face[height - j - 1][i]
      end
    end
    new_face
  end

  def self.rotate_face_half(face)
    new_face = face
    2.times { new_face = rotate_face_clockwise(new_face) }
    new_face
  end

  def self.rotate_face_counterclockwise(face)
    new_face = face
    3.times { new_face = rotate_face_clockwise(new_face) }
    new_face
  end

  def self.flip_face(face)
    width = face.map(&:length).max
    height = face.length
    new_face = Array.new(height)
    new_face.map! { String.new.ljust(width) }
    (0...height).each do |j|
      (0...width).each do |i|
        new_face[j][i] = face[-j - 1][i]
      end
    end
    new_face
  end

  def self.mirror_face(face)
    width = face.map(&:length).max
    height = face.length
    new_face = Array.new(height)
    new_face.map! { String.new.ljust(width) }
    (0...height).each do |j|
      (0...width).each do |i|
        new_face[j][i] = face[j][-i - 1]
      end
    end
    new_face
  end

  def self.score_face(face)
    face.join('').codepoints.inject(:+)
  end

  def rotate
    @faces =
      {
        top: self.class.rotate_face_clockwise(@faces[:top]),
        front: @faces[:right],
        right: @faces[:back],
        back: @faces[:left],
        left: @faces[:front],
        bottom: self.class.rotate_face_counterclockwise(@faces[:bottom])
      }
  end

  def flip_up
    @faces =
      {
        top: @faces[:front],
        front: @faces[:bottom],
        bottom: self.class.rotate_face_half(@faces[:back]),
        back: self.class.rotate_face_half(@faces[:top]),
        right: self.class.rotate_face_clockwise(@faces[:right]),
        left: self.class.rotate_face_clockwise(@faces[:left])
      }
  end

  def canonical
    @faces[:top].join('') + @faces[:front].join('') +
      @faces[:right].join('') + @faces[:back].join('') +
      @faces[:left].join('') + @faces[:bottom].join('')
  end
end

known_cubes = Set.new

file = $stdin
#file = File.open('example2')
lines = []
while true
  line = file.gets
  if !line || line.strip.empty?
    break if lines.empty?
    cube = Cube.new(lines)
    lines = []
    canonicals = cube.canonicals
    next if canonicals.any? {|c| known_cubes.include?(c) }
    known_cubes.merge(canonicals)
    puts lines
    puts ''
  else
    line = line[0...-1]
    lines << line
  end
end
